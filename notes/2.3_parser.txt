we define parser code to build the AST 
we want to parse something like "x+y" 
(which is returned as three tokens by the lexer)
into an AST which could be generated by some calls

getNextToken looks one token ahead at what the lexer is returning
we assume CurTok is the current token which needs to be parsed

LogError routines are helper routines which the parser will use to handle errors
for errors in routines that have various return types; they will always return null
the error recovery in the parser should be improved in the future

we implement the first piece of our grammar: numeric literals
we define a function which parses each production in our grammar

for numeric literals we define ParseNumberExpr()
which expects to be called when the current token is a tok_number token
it takes the current number value, creates a NumberExprAST node, 
advances the lexer to the next token, and then returns

this routine consumes all of the tokens which correspond to the 
production and returns the lexer buffer with the next token 
(not part of the grammar production) ready to go
this is standard for recursive descent parsers

when ParseParentExpr() is called, the function expects the current token
is a '(' token, but after parsing the subexpression, it's possible there is 
no ')' token; and we return null on an error 

ParseParentExpr() calls ParseExpression which can call ParseParenExpr() 
recursion is powerful since we can handle recursive grammars and keeps
production simple

parentheses do not cause construction of AST nodes, they guide the parser 
and provide grouping; they are otherwise unnecessary

ParseIdentifierExpr() expects to be called if the current token is a 
tok_identifier token
it uses look-ahead to determine if the current identifier is a stand alone 
variable reference or if it is a function call expression
it handles this by checking to see if the token after the identifier is a '('
token and constructs a VariableExprAST or CallExprAST node as appropriate

we define a helper function to wrap together the simple expression-parsing logic
into one entry point; we call this class of expressions "primary" 
to parse an arbitrary primary expression, we determine what expression type it is

ParsePrimary() uses look-ahead to determine what expression is being consumed
it then makes a call to the corresponding function which parses the expression

binary expressions are harder to parse because some operators have higher precedence 
than others, an efficient and elegant way to handle this is with operator-precedence
parsing; which uses precedence of binary operators to guide recursion

GetTokPrecedence returns the precedence for the current token, or -1 if the token is 
not a binary operator

the idea of operator precedence parsing is to break down an expression with binary 
operators into pieces; the expression "a+b+(c+d)*e*f+g" should parse the leading
primary expression "a", and then the pairs [+, b], [+, (c+d)], [*, e], [*, f] and [+, g]

since parentheses are primary expressions, the binary expression parser does not 
need to worry about nested subexpressions such as (c + d)

an expression is a primary epxression potentially followed by a sequence of 
[binop, primaryexpr] pairs

ParseBinOpRHS parses the sequence of [binop, primaryexpr] pairs
it takes a precedence and a pointer to an expression for the part that has been
parsed so far, "binorphs" is allowed to be empty; in which case it returns the 
expression it was passed

the precedence value passed in ParseBinOpRHS indicates the minimal operator precedence
the function is allowed to consume; if the current pair stream is [+, x] and ParseBinOpRHS
is passed a precedence of 40, it will not consume any tokens


